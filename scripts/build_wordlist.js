#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");
const { execFile } = require("child_process");

const FREQ_SOURCE = {
  name: "HermitDave FrequencyWords (OpenSubtitles, 2018)",
  url: "https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/cs/cs_50k.txt",
};

const DICT_SOURCE = {
  name: "LibreOffice cs_CZ Hunspell dictionary",
  url: "https://raw.githubusercontent.com/LibreOffice/dictionaries/master/cs_CZ/cs_CZ.dic",
};

const PROJECT_ROOT = path.resolve(__dirname, "..");
const WORDS_PATH = path.join(PROJECT_ROOT, "words.js");
const SOLUTION_TARGET_COUNT = 512;

function fetchText(url) {
  return new Promise((resolve, reject) => {
    execFile("curl", ["-fsSL", url], { encoding: "utf8", maxBuffer: 20 * 1024 * 1024 }, (error, stdout, stderr) => {
      if (error) {
        reject(new Error(`Failed to download ${url}: ${stderr || error.message}`));
        return;
      }
      resolve(stdout);
    });
  });
}

function normalizeWord(word) {
  return word.normalize("NFC").toUpperCase();
}

function isAlphabetic(word) {
  return Array.from(word).every((char) => /\p{L}/u.test(char));
}

function isFiveGlyphs(word) {
  return Array.from(word).length === 5;
}

function parseDictionary(text) {
  const dictionary = new Set();

  for (const rawLine of text.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#") || line.startsWith("/")) continue;
    const [word] = line.split("/");
    const normalized = normalizeWord(word);
    if (isFiveGlyphs(normalized) && isAlphabetic(normalized)) {
      dictionary.add(normalized);
    }
  }

  return dictionary;
}

function parseFrequencyList(text, dictionary) {
  const seen = new Set();
  const ranked = [];

  let rank = 0;
  for (const rawLine of text.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line) continue;
    const [word, freq] = line.split(/\s+/);
    const normalized = normalizeWord(word);
    if (!isAlphabetic(normalized) || !isFiveGlyphs(normalized)) continue;
    if (!dictionary.has(normalized)) continue;
    if (seen.has(normalized)) continue;

    const frequency = Number(freq) || 0;
    ranked.push({ word: normalized, frequency, rank });
    seen.add(normalized);
    rank += 1;
  }

  return ranked;
}

function formatArray(values) {
  return values.map((word, idx) => `  "${word}"${idx === values.length - 1 ? "" : ","}`).join("\n");
}

function renderWordsFile({ solutions, allowed }) {
  const header = `// Autogenerated by scripts/build_wordlist.js\n// Sources:\n// - ${FREQ_SOURCE.name}: ${FREQ_SOURCE.url}\n// - ${DICT_SOURCE.name}: ${DICT_SOURCE.url}`;

  return `${header}\n\nconst SOLUTIONS = [\n${formatArray(solutions)}\n];\n\nconst ALLOWED = [\n${formatArray(allowed)}\n];\n`;
}

async function buildWordlists() {
  const [freqText, dictText] = await Promise.all([fetchText(FREQ_SOURCE.url), fetchText(DICT_SOURCE.url)]);
  const dictionary = parseDictionary(dictText);
  const ranked = parseFrequencyList(freqText, dictionary);

  if (ranked.length < SOLUTION_TARGET_COUNT) {
    throw new Error(`Not enough validated words: wanted ${SOLUTION_TARGET_COUNT}, got ${ranked.length}`);
  }

  const solutions = ranked.slice(0, SOLUTION_TARGET_COUNT).map((entry) => entry.word);

  const allowedSet = new Set(solutions);
  for (const word of dictionary) {
    allowedSet.add(word);
  }

  const allowed = Array.from(allowedSet).sort((a, b) => a.localeCompare(b, "cs"));

  return { solutions, allowed };
}

function compareFiles(expectedContent, filePath) {
  if (!fs.existsSync(filePath)) return false;
  const current = fs.readFileSync(filePath, "utf8");
  return current === expectedContent;
}

async function main() {
  const checkOnly = process.argv.includes("--check");
  const { solutions, allowed } = await buildWordlists();
  const output = renderWordsFile({ solutions, allowed });

  if (checkOnly) {
    const matches = compareFiles(output, WORDS_PATH);
    if (!matches) {
      console.error("words.js is out of date. Run `npm run build:words` to regenerate.");
      process.exit(1);
    }
    console.log("words.js is up to date.");
    return;
  }

  fs.writeFileSync(WORDS_PATH, output, "utf8");
  console.log(`Wrote ${solutions.length} solutions and ${allowed.length} allowed words to words.js`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
